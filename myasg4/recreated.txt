CH1:Q:Multiprogramming is the rapid switching of the CPU between multiple proc- esses in memory.Input spooling is the technique of reading in jobs, for example, from cards, onto the disk, so that when the currently executing processes are finished, there will be work waiting for the CPU.The prime reason for multiprogramming is to give the CPU something to do while waiting for I/O to complete.A trap instruction switches the execution mode of a CPU from the user mode to the kernel mode.A system call allows a user process to access and execute operating system functions inside the kernel. User programs use system calls to invoke operat- ing system services.CH2:Process creation1System initialization2Execution of a process creation system call by  a running process3A user resquest to create a new process4Initiation of a batch job.ProcessTermination1Normal exit2Error exit(voluntary)3Fatal error4Killed by another process(invol.)Ex.interrupt:process3running-disk interrupt-p3's pc,psw pushed onto stack by interpt hdware-jmp to the addr spcecified in the interpt vec.PerProcessItems:addr space;global var;open files;child processes;pending alarms; signals and signal handlers;accounting info.PerThreadItems:pc;regs;stack;state.CriticalRegions:4conditions to provide mutual exclusion:1no two processes may simt.ly be in critical region2no assumptions may be made about speeds or num of CPUs3no processes running outside its critical region may block another process4a process amy not wait 4ever to enter its critical region.Semaphore:if ea process does a down just before entering its critical region and an up just after leaving it, mutex is guaranteed.4conditions for Ddlc:mutual excultion;hold&wait;no preemption;circular wait.Ea rsc is assigned to at most 1 process;A process holding rscs can request more rscs;Previously granted rscs cannot be forcibly taken away;There must be a circular chani of 2 or more processe.Ddlc prevention:Me:spool everyth;H&W:request all rscs initially;Np:Take rscs away if there's not a complete set;Cw:Order rscs numerically.Q:U could have a reg containing a ptr to the current process table entry. When I/O completed, the CPU would store the current machine state in the current process table entry. Then it would go to the interrupt vector for the interrupting device and fetch a pointer to another process table entry.This process would then be started up.High-level languages do not allow the access to CP///U hardware.Also, interrupt service routines must execute ARAP.The priority inversion problem occurs when a low-priority process is in its critical region and suddenly a high-priority process becomes ready and is scheduled. If it uses busy waiting, it will run forever. With usr-level threads, it cant happen that a low-priority thread is suddenly preempted to allow a high-priority thread run.There is no preemption. With kernel-level threads this problem can arise.It could happen that the runtime system is precisely at the point of blocking or unblocking a thread, and is busy manipulating the scheduling queues. This would be a very inopportune moment for the clock interrupt handler to begin inspecting those queues to see if it was time to do thread switching, since they might be in an inconsistent state. One solution is to set a flag when the run- time system is entered. The clock handler would see this and set its own flag, then return. When the runtime system finished, it would check the clock flag, see that a clock interrupt occurred, and now run the clock handler.It is very expensive to implement. Each time any variable that appears in a predicate on which som/////e process is waiting changes, the run-time system must re-evaluate the predicate to see if the process can be unblocked. With the Hoare and Brinch Hansen monitors, processes can only be awakened on a signal primitive.In simple cases it may be possible to determine whether I/O will be limiting by looking at sou/////rce code. For instance a program that reads all its input files into buffers at the start will probably not be I/O bound, but a problem that reads and writes incrementally to a number of different files (such as a compi- ler) is likely to be I/O bound. If the operating system provides a facility such as the UNIX ps command that can tell you the amount of CPU time used by a program, you can compare this with the total time to complete execution of the program. This is, of course, most meaningful on a system where you are the only user.CH6:Consider the ex. of two processes that want to record a scanned document on a CD.When process B requests the CDrecorder, it is impossible to determine if granting this request will lead to an unsafe state, because it is not known if A will need the CD-ROM recorder later and B will need the scanner later.Change the semantics of requesting a new resource as follows.If a process asks for a new resource and it is available, it gets the resource and keeps what it already has.If///// the new resource is not available, all existing resources are released.